---
description:
globs:
alwaysApply: true
---

# Cursor AI 编码规则 - Flutter 项目 (Riverpod + Dio + GoRouter)

## 核心原则

### 架构师视角
- **Clean Architecture**: 采用 Clean Architecture 分层，结合 Riverpod 的响应式编程
- **Provider-Based 状态管理**: 使用 Riverpod 进行声明式状态管理和依赖注入
- **类型安全路由**: GoRouter 实现类型安全的声明式路由
- **网络层抽象**: Dio + Interceptors 构建可维护的网络层
- **测试友好**: Provider 可独立测试，支持 Mock 和单元测试

### 产品经理视角  
- **用户体验**: 流畅的页面切换、智能缓存、离线支持
- **业务逻辑**: 清晰的数据流和状态同步
- **错误边界**: 优雅的错误处理和用户反馈
- **性能监控**: 网络请求监控和状态变化追踪
- **功能开关**: 基于 Provider 的功能开关系统

## 技术栈配置

### 1. 核心依赖
```yaml
dependencies:
  flutter: 
    sdk: flutter
  
  # 状态管理
  flutter_riverpod: ^2.4.9
  riverpod_annotation: ^2.3.3
  
  # 路由管理
  go_router: ^12.1.3
  
  # 网络请求
  dio: ^5.4.0
  
  # 工具库
  freezed_annotation: ^2.4.1
  json_annotation: ^4.8.1
  equatable: ^2.0.5
  
dev_dependencies:
  # 代码生成
  build_runner: ^2.4.7
  riverpod_generator: ^2.3.9
  freezed: ^2.4.6
  json_serializable: ^6.7.1
  
  # 测试
  flutter_test:
    sdk: flutter
  mocktail: ^1.0.2
```

## 文件组织结构

```
lib/
├── core/                           # 核心功能
│   ├── constants/
│   │   ├── api_constants.dart     # API 常量
│   │   └── app_constants.dart     # 应用常量
│   ├── network/
│   │   ├── dio_client.dart        # Dio 客户端配置
│   │   ├── interceptors/          # 网络拦截器
│   │   └── network_exceptions.dart
│   ├── router/
│   │   ├── app_router.dart        # GoRouter 配置
│   │   └── route_names.dart       # 路由名称常量
│   ├── errors/
│   │   ├── failures.dart          # 错误类型定义
│   │   └── error_handler.dart     # 全局错误处理
│   └── utils/
│       ├── logger.dart
│       └── validators.dart
├── features/                       # 功能模块
│   └── user_profile/
│       ├── data/
│       │   ├── datasources/
│       │   │   ├── user_remote_datasource.dart
│       │   │   └── user_local_datasource.dart
│       │   ├── models/
│       │   │   └── user_model.dart
│       │   └── repositories/
│       │       └── user_repository_impl.dart
│       ├── domain/
│       │   ├── entities/
│       │   │   └── user.dart
│       │   └── repositories/
│       │       └── user_repository.dart
│       └── presentation/
│           ├── providers/
│           │   ├── user_providers.dart
│           │   └── user_notifier.dart
│           ├── pages/
│           │   └── user_profile_page.dart
│           └── widgets/
│               └── user_profile_widgets.dart
├── shared/
│   ├── providers/                  # 全局 Providers
│   │   ├── dio_provider.dart
│   │   └── shared_preferences_provider.dart
│   ├── widgets/
│   └── extensions/
└── main.dart
```

## Riverpod 状态管理最佳实践

### 1. Provider 定义
```dart
// ✅ 使用 Riverpod Generator
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'user_providers.g.dart';

// ✅ Repository Provider
@riverpod
UserRepository userRepository(UserRepositoryRef ref) {
  final dio = ref.watch(dioProvider);
  return UserRepositoryImpl(
    remoteDataSource: UserRemoteDataSourceImpl(dio),
    localDataSource: UserLocalDataSourceImpl(),
  );
}

// ✅ Future Provider for one-time data
@riverpod
Future<User> userProfile(UserProfileRef ref, String userId) async {
  final repository = ref.watch(userRepositoryProvider);
  final result = await repository.getUserProfile(userId);
  
  return result.fold(
    (failure) => throw failure,
    (user) => user,
  );
}

// ✅ Stream Provider for real-time data
@riverpod
Stream<List<User>> usersList(UsersListRef ref) {
  final repository = ref.watch(userRepositoryProvider);
  return repository.watchUsers();
}

// ✅ 复杂状态使用 AsyncNotifier
@riverpod
class UserProfileNotifier extends _$UserProfileNotifier {
  @override
  Future<User?> build() async {
    // 初始化逻辑
    return null;
  }

  Future<void> updateProfile(User user) async {
    state = const AsyncLoading();
    
    final repository = ref.read(userRepositoryProvider);
    final result = await repository.updateUserProfile(user);
    
    result.fold(
      (failure) => state = AsyncError(failure, StackTrace.current),
      (user) => state = AsyncData(user),
    );
  }

  Future<void> refreshProfile(String userId) async {
    state = const AsyncLoading();
    
    try {
      final repository = ref.read(userRepositoryProvider);
      final result = await repository.getUserProfile(userId);
      
      result.fold(
        (failure) => throw failure,
        (user) => state = AsyncData(user),
      );
    } catch (error, stackTrace) {
      state = AsyncError(error, stackTrace);
    }
  }
}
```

### 2. 在 Widget 中使用 Provider
```dart
// ✅ ConsumerWidget 基础用法
class UserProfilePage extends ConsumerWidget {
  const UserProfilePage({
    super.key,
    required this.userId,
  });

  final String userId;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final userAsyncValue = ref.watch(userProfileProvider(userId));
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('User Profile'),
        actions: [
          IconButton(
            onPressed: () => ref.refresh(userProfileProvider(userId)),
            icon: const Icon(Icons.refresh),
          ),
        ],
      ),
      body: userAsyncValue.when(
        data: (user) => _UserProfileContent(user: user),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stack) => _ErrorView(
          error: error,
          onRetry: () => ref.refresh(userProfileProvider(userId)),
        ),
      ),
    );
  }
}

// ✅ ConsumerStatefulWidget 复杂用法
class UserEditPage extends ConsumerStatefulWidget {
  const UserEditPage({super.key, required this.userId});

  final String userId;

  @override
  ConsumerState<UserEditPage> createState() => _UserEditPageState();
}

class _UserEditPageState extends ConsumerState<UserEditPage> {
  final _formKey = GlobalKey<FormState>();
  late TextEditingController _nameController;
  late TextEditingController _emailController;

  @override
  void initState() {
    super.initState();
    _nameController = TextEditingController();
    _emailController = TextEditingController();
  }

  @override
  void dispose() {
    _nameController.dispose();
    _emailController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final userAsyncValue = ref.watch(userProfileProvider(widget.userId));
    final userNotifier = ref.read(userProfileNotifierProvider.notifier);
    
    // ✅ 监听状态变化
    ref.listen<AsyncValue<User?>>(
      userProfileNotifierProvider,
      (previous, next) {
        next.whenOrNull(
          error: (error, _) => _showErrorSnackBar(error.toString()),
          data: (user) => _showSuccessSnackBar('Profile updated successfully'),
        );
      },
    );

    return Scaffold(
      appBar: AppBar(
        title: const Text('Edit Profile'),
        actions: [
          TextButton(
            onPressed: () => _saveProfile(userNotifier),
            child: const Text('Save'),
          ),
        ],
      ),
      body: userAsyncValue.when(
        data: (user) {
          // ✅ 初始化表单数据
          WidgetsBinding.instance.addPostFrameCallback((_) {
            _nameController.text = user.name;
            _emailController.text = user.email;
          });
          
          return _EditForm();
        },
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, _) => _ErrorView(error: error),
      ),
    );
  }
}
```

### 3. 依赖管理和依赖注入
```dart
// ✅ 全局 Providers (shared/providers/app_providers.dart)
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'app_providers.g.dart';

// ✅ Dio 配置
@riverpod
Dio dio(DioRef ref) {
  final dio = Dio();
  
  // 基础配置
  dio.options = BaseOptions(
    baseUrl: ApiConstants.baseUrl,
    connectTimeout: const Duration(seconds: 30),
    receiveTimeout: const Duration(seconds: 30),
    headers: {
      'Content-Type': 'application/json',
    },
  );

  // 添加拦截器
  dio.interceptors.addAll([
    ref.read(authInterceptorProvider),
    ref.read(loggingInterceptorProvider),
    ref.read(errorInterceptorProvider),
  ]);

  return dio;
}

// ✅ SharedPreferences Provider
@riverpod
Future<SharedPreferences> sharedPreferences(SharedPreferencesRef ref) async {
  return SharedPreferences.getInstance();
}

// ✅ 认证拦截器
@riverpod
AuthInterceptor authInterceptor(AuthInterceptorRef ref) {
  return AuthInterceptor(ref);
}

class AuthInterceptor extends Interceptor {
  AuthInterceptor(this.ref);
  
  final Ref ref;

  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {
    final token = ref.read(authTokenProvider);
    if (token != null) {
      options.headers['Authorization'] = 'Bearer $token';
    }
    handler.next(options);
  }

  @override
  void onError(DioException err, ErrorInterceptorHandler handler) {
    if (err.response?.statusCode == 401) {
      // Token 过期，清除认证状态
      ref.read(authNotifierProvider.notifier).logout();
    }
    handler.next(err);
  }
}
```

## GoRouter 路由配置

### 1. 路由定义
```dart
// ✅ 路由配置 (core/router/app_router.dart)
import 'package:go_router/go_router.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'app_router.g.dart';

@riverpod
GoRouter goRouter(GoRouterRef ref) {
  final authState = ref.watch(authNotifierProvider);
  
  return GoRouter(
    initialLocation: RoutePaths.splash,
    debugLogDiagnostics: true,
    redirect: (context, state) {
      final isAuthenticated = authState.maybeWhen(
        data: (user) => user != null,
        orElse: () => false,
      );
      
      final isAuthenticating = authState.isLoading;
      final isGoingToAuth = state.location.startsWith('/auth');
      
      // 正在认证中，显示启动页
      if (isAuthenticating) {
        return RoutePaths.splash;
      }
      
      // 未认证用户重定向到登录页
      if (!isAuthenticated && !isGoingToAuth) {
        return RoutePaths.login;
      }
      
      // 已认证用户访问认证页面，重定向到首页
      if (isAuthenticated && isGoingToAuth) {
        return RoutePaths.home;
      }
      
      return null;
    },
    routes: [
      // ✅ 启动页
      GoRoute(
        path: RoutePaths.splash,
        builder: (context, state) => const SplashPage(),
      ),
      
      // ✅ 认证路由
      GoRoute(
        path: RoutePaths.login,
        builder: (context, state) => const LoginPage(),
      ),
      GoRoute(
        path: RoutePaths.register,
        builder: (context, state) => const RegisterPage(),
      ),
      
      // ✅ Shell Route for bottom navigation
      ShellRoute(
        builder: (context, state, child) => MainShell(child: child),
        routes: [
          GoRoute(
            path: RoutePaths.home,
            builder: (context, state) => const HomePage(),
          ),
          GoRoute(
            path: RoutePaths.profile,
            builder: (context, state) => const ProfilePage(),
            routes: [
              // ✅ 嵌套路由
              GoRoute(
                path: 'edit',
                builder: (context, state) => const EditProfilePage(),
              ),
            ],
          ),
        ],
      ),
      
      // ✅ 带参数的路由
      GoRoute(
        path: '/user/:userId',
        builder: (context, state) {
          final userId = state.pathParameters['userId']!;
          return UserDetailPage(userId: userId);
        },
      ),
      
      // ✅ 带查询参数的路由
      GoRoute(
        path: RoutePaths.search,
        builder: (context, state) {
          final query = state.uri.queryParameters['q'] ?? '';
          final category = state.uri.queryParameters['category'];
          return SearchPage(query: query, category: category);
        },
      ),
    ],
    
    // ✅ 错误页面
    errorBuilder: (context, state) => ErrorPage(error: state.error),
  );
}

// ✅ 路由常量
abstract class RoutePaths {
  static const String splash = '/splash';
  static const String login = '/auth/login';
  static const String register = '/auth/register';
  static const String home = '/';
  static const String profile = '/profile';
  static const String search = '/search';
}
```

### 2. 类型安全的路由导航
```dart
// ✅ 路由扩展方法
extension AppRouterExtension on GoRouter {
  // ✅ 导航到用户详情页
  void goToUserDetail(String userId) {
    go('/user/$userId');
  }
  
  // ✅ 导航到搜索页
  void goToSearch({String? query, String? category}) {
    final queryParams = <String, String>{};
    if (query != null) queryParams['q'] = query;
    if (category != null) queryParams['category'] = category;
    
    final uri = Uri(path: RoutePaths.search, queryParameters: queryParams);
    go(uri.toString());
  }
  
  // ✅ 返回指定层数
  void popUntil(String location) {
    while (routerDelegate.currentConfiguration.location != location) {
      if (!canPop()) break;
      pop();
    }
  }
}

// ✅ 在 Widget 中使用
class SearchWidget extends ConsumerWidget {
  const SearchWidget({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final router = ref.read(goRouterProvider);
    
    return SearchBar(
      onSubmitted: (query) {
        router.goToSearch(query: query);
      },
    );
  }
}
```

### 3. 路由状态管理
```dart
// ✅ 路由状态 Provider
@riverpod
String currentRoute(CurrentRouteRef ref) {
  final router = ref.watch(goRouterProvider);
  return router.routerDelegate.currentConfiguration.location;
}

// ✅ 面包屑导航
@riverpod
List<String> breadcrumbs(BreadcrumbsRef ref) {
  final currentRoute = ref.watch(currentRouteProvider);
  return currentRoute.split('/').where((s) => s.isNotEmpty).toList();
}

// ✅ 底部导航栏状态
@riverpod
int bottomNavIndex(BottomNavIndexRef ref) {
  final currentRoute = ref.watch(currentRouteProvider);
  
  return switch (currentRoute) {
    '/' => 0,
    '/profile' => 1,
    '/search' => 2,
    _ => 0,
  };
}
```

## Dio 网络层最佳实践

### 1. API 服务抽象
```dart
// ✅ API 服务基类
abstract class ApiService {
  Future<ApiResponse<T>> get<T>(
    String path, {
    Map<String, dynamic>? queryParameters,
    Options? options,
  });
  
  Future<ApiResponse<T>> post<T>(
    String path, {
    dynamic data,
    Map<String, dynamic>? queryParameters,
    Options? options,
  });
  
  Future<ApiResponse<T>> put<T>(
    String path, {
    dynamic data,
    Map<String, dynamic>? queryParameters,
    Options? options,
  });
  
  Future<ApiResponse<T>> delete<T>(
    String path, {
    Map<String, dynamic>? queryParameters,
    Options? options,
  });
}

// ✅ API 响应包装
@freezed
class ApiResponse<T> with _$ApiResponse<T> {
  const factory ApiResponse.success({
    required T data,
    required int statusCode,
    String? message,
  }) = ApiSuccess<T>;
  
  const factory ApiResponse.error({
    required String message,
    required int statusCode,
    dynamic error,
  }) = ApiError<T>;
}

// ✅ API 服务实现
@riverpod
ApiService apiService(ApiServiceRef ref) {
  final dio = ref.watch(dioProvider);
  return ApiServiceImpl(dio);
}

class ApiServiceImpl implements ApiService {
  ApiServiceImpl(this._dio);
  
  final Dio _dio;

  @override
  Future<ApiResponse<T>> get<T>(
    String path, {
    Map<String, dynamic>? queryParameters,
    Options? options,
  }) async {
    try {
      final response = await _dio.get<T>(
        path,
        queryParameters: queryParameters,
        options: options,
      );
      
      return ApiResponse.success(
        data: response.data as T,
        statusCode: response.statusCode ?? 200,
      );
    } on DioException catch (e) {
      return _handleDioError<T>(e);
    }
  }

  ApiResponse<T> _handleDioError<T>(DioException error) {
    return switch (error.type) {
      DioExceptionType.connectionTimeout => ApiResponse.error(
          message: 'Connection timeout',
          statusCode: 408,
          error: error,
        ),
      DioExceptionType.sendTimeout => ApiResponse.error(
          message: 'Send timeout',
          statusCode: 408,
          error: error,
        ),
      DioExceptionType.receiveTimeout => ApiResponse.error(
          message: 'Receive timeout',
          statusCode: 408,
          error: error,
        ),
      DioExceptionType.badResponse => ApiResponse.error(
          message: error.response?.data['message'] ?? 'Server error',
          statusCode: error.response?.statusCode ?? 500,
          error: error,
        ),
      DioExceptionType.cancel => ApiResponse.error(
          message: 'Request cancelled',
          statusCode: 499,
          error: error,
        ),
      _ => ApiResponse.error(
          message: 'Network error',
          statusCode: 0,
          error: error,
        ),
    };
  }
}
```

### 2. Repository 实现
```dart
// ✅ Repository 实现
class UserRepositoryImpl implements UserRepository {
  UserRepositoryImpl({
    required this.apiService,
    required this.localDataSource,
  });

  final ApiService apiService;
  final UserLocalDataSource localDataSource;

  @override
  Future<Either<Failure, User>> getUserProfile(String userId) async {
    try {
      final response = await apiService.get<Map<String, dynamic>>(
        '/users/$userId',
      );
      
      return response.when(
        success: (data, statusCode, message) {
          final user = UserModel.fromJson(data).toDomain();
          // 缓存到本地
          localDataSource.cacheUser(user);
          return Right(user);
        },
        error: (message, statusCode, error) {
          // 网络错误时尝试从本地获取
          if (statusCode == 0) {
            final cachedUser = await localDataSource.getCachedUser(userId);
            if (cachedUser != null) {
              return Right(cachedUser);
            }
          }
          return Left(NetworkFailure(message));
        },
      );
    } catch (e) {
      return Left(UnknownFailure(e.toString()));
    }
  }

  @override
  Stream<List<User>> watchUsers() async* {
    // 先返回本地缓存数据
    final cachedUsers = await localDataSource.getCachedUsers();
    if (cachedUsers.isNotEmpty) {
      yield cachedUsers;
    }
    
    // 然后获取远程数据
    final response = await apiService.get<List<dynamic>>('/users');
    
    await response.when(
      success: (data, statusCode, message) async {
        final users = data
            .cast<Map<String, dynamic>>()
            .map((json) => UserModel.fromJson(json).toDomain())
            .toList();
        
        await localDataSource.cacheUsers(users);
        yield users;
      },
      error: (message, statusCode, error) {
        // 网络错误时保持本地数据
        if (cachedUsers.isEmpty) {
          throw NetworkException(message);
        }
      },
    );
  }
}
```

## 错误处理和监控

### 1. 全局错误处理
```dart
// ✅ 全局错误处理 Provider
@riverpod
GlobalErrorHandler globalErrorHandler(GlobalErrorHandlerRef ref) {
  return GlobalErrorHandler(ref);
}

class GlobalErrorHandler {
  GlobalErrorHandler(this.ref);
  
  final Ref ref;

  void handleError(Object error, StackTrace? stackTrace) {
    // 记录错误
    AppLogger.e('Global error occurred', error, stackTrace);
    
    // 上报崩溃
    FirebaseCrashlytics.instance.recordError(error, stackTrace);
    
    // 根据错误类型显示不同的用户提示
    final errorMessage = switch (error.runtimeType) {
      NetworkException => 'Please check your internet connection',
      ValidationException => (error as ValidationException).message,
      AuthException => 'Please login again',
      _ => 'Something went wrong. Please try again.',
    };
    
    // 显示错误提示
    ref.read(snackbarServiceProvider).showError(errorMessage);
  }
}

// ✅ 错误边界 Widget
class ErrorBoundary extends ConsumerWidget {
  const ErrorBoundary({
    super.key,
    required this.child,
  });

  final Widget child;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Consumer(
      builder: (context, ref, _) {
        // 监听全局错误状态
        final errorState = ref.watch(globalErrorStateProvider);
        
        if (errorState != null) {
          return ErrorPage(
            error: errorState,
            onRetry: () {
              ref.read(globalErrorStateProvider.notifier).clearError();
            },
          );
        }
        
        return child;
      },
    );
  }
}
```

### 2. 网络状态监控
```dart
// ✅ 网络状态 Provider
@riverpod
Stream<ConnectivityResult> connectivity(ConnectivityRef ref) {
  return Connectivity().onConnectivityChanged;
}

@riverpod
bool isOnline(IsOnlineRef ref) {
  final connectivityAsyncValue = ref.watch(connectivityProvider);
  
  return connectivityAsyncValue.maybeWhen(
    data: (connectivity) => connectivity != ConnectivityResult.none,
    orElse: () => true, // 默认假设有网络
  );
}

// ✅ 在 Widget 中使用网络状态
class NetworkAwareWidget extends ConsumerWidget {
  const NetworkAwareWidget({super.key, required this.child});
  
  final Widget child;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final isOnline = ref.watch(isOnlineProvider);
    
    return Stack(
      children: [
        child,
        if (!isOnline)
          Positioned(
            top: 0,
            left: 0,
            right: 0,
            child: Container(
              color: Colors.red,
              padding: const EdgeInsets.all(8),
              child: const Text(
                'No internet connection',
                style: TextStyle(color: Colors.white),
                textAlign: TextAlign.center,
              ),
            ),
          ),
      ],
    );
  }
}
```

## 测试最佳实践

### 1. Provider 测试
```dart
// ✅ Provider 测试
void main() {
  group('UserProfileNotifier', () {
    late ProviderContainer container;
    late MockUserRepository mockRepository;

    setUp(() {
      mockRepository = MockUserRepository();
      container = ProviderContainer(
        overrides: [
          userRepositoryProvider.overrideWithValue(mockRepository),
        ],
      );
    });

    tearDown(() {
      container.dispose();
    });

    test('should load user profile successfully', () async {
      // Arrange
      const user = User(id: '1', name: 'Test User', email: 'test@test.com');
      when(() => mockRepository.getUserProfile('1'))
          .thenAnswer((_) async => const Right(user));

      // Act
      final notifier = container.read(userProfileNotifierProvider.notifier);
      await notifier.refreshProfile('1');

      // Assert
      final state = container.read(userProfileNotifierProvider);
      expect(state.value, user);
    });

    test('should handle error when loading user profile', () async {
      // Arrange
      when(() => mockRepository.getUserProfile('1'))
          .thenAnswer((_) async => const Left(NetworkFailure('Network error')));

      // Act
      final notifier = container.read(userProfileNotifierProvider.notifier);
      await notifier.refreshProfile('1');

      // Assert
      final state = container.read(userProfileNotifierProvider);
      expect(state.hasError, isTrue);
      expect(state.error, isA<NetworkFailure>());
    });
  });
}
```

### 2. Widget 测试
```dart
// ✅ Widget 测试
void main() {
  group('UserProfilePage', () {
    late MockUserRepository mockRepository;

    setUp(() {
      mockRepository = MockUserRepository();
    });

    testWidgets('displays user profile when data is loaded', (tester) async {
      // Arrange
      const user = User(id: '1', name: 'Test User', email: 'test@test.com');
      when(() => mockRepository.getUserProfile('1'))
          .thenAnswer((_) async => const Right(user));

      // Act
      await tester.pumpWidget(
        ProviderScope(
          overrides: [
            userRepositoryProvider.overrideWithValue(mockRepository),
          ],
          child: const MaterialApp(
            home: UserProfilePage(userId: '1'),
          ),
        ),
      );

      // Wait for the future to complete
      await tester.pumpAndSettle();

      // Assert
      expect(find.text('Test User'), findsOneWidget);
      expect(find.text('test@test.com'), findsOneWidget);
    });

    testWidgets('displays loading indicator while loading', (tester) async {
      // Arrange
      when(() => mockRepository.getUserProfile('1'))
          .thenAnswer((_) => Future.delayed(const Duration(seconds: 1))
              .then((_) => const Right(User(id: '1', name: 'Test', email: 'test@test.com'))));

      // Act
      await tester.pumpWidget(
        ProviderScope(
          overrides: [
            userRepositoryProvider.overrideWithValue(mockRepository),
          ],
          child: const MaterialApp(
            home: UserProfilePage(userId: '1'),
          ),
        ),
      );

      // Assert
      expect(find.byType(CircularProgressIndicator), findsOneWidget);
    });
  });
}
```

## 性能优化建议

### 1. Provider 性能优化
```dart
// ✅ 使用 select 优化性能
class UserNameWidget extends ConsumerWidget {
  const UserNameWidget({super.key, required this.userId});
  
  final String userId;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // ✅ 只监听 name 字段变化
    final userName = ref.watch(
      userProfileProvider(userId).select((userAsync) => 
        userAsync.maybeWhen(
          data: (user) => user.name,
          orElse: () => null,
        )
      ),
    );
    
    return Text(userName ?? 'Loading...');
  }
}

// ✅ 缓存计算结果
@riverpod
String userDisplayName(UserDisplayNameRef ref, String userId) {
  final userAsync = ref.watch(userProfileProvider(userId));
  
  return userAsync.maybeWhen(
    data: (user) => '${user.name} (${user.email})',
    orElse: () => 'Unknown User',
  );
}

// ✅ 使用 family 缓存不同参数的结果
@riverpod
Future<List<User>> filteredUsers(
  FilteredUsersRef ref,
  String searchQuery,
) async {
  final allUsers = await ref.watch(usersListProvider.future);
  
  if (searchQuery.isEmpty) return allUsers;
  
  return allUsers.where((user) => 
    user.name.toLowerCase().contains(searchQuery.toLowerCase()) ||
    user.email.toLowerCase().contains(searchQuery.toLowerCase())
  ).toList();
}
```

### 2. 智能缓存策略
```dart
// ✅ 带缓存过期的 Provider
@riverpod
class CachedUserProfile extends _$CachedUserProfile {
  static const _cacheDuration = Duration(minutes: 5);
  DateTime? _lastFetchTime;

  @override
  Future<User?> build(String userId) async {
    final now = DateTime.now();
    
    // 检查缓存是否过期
    if (_lastFetchTime != null && 
        now.difference(_lastFetchTime!) < _cacheDuration) {
      return state.valueOrNull;
    }
    
    final repository = ref.watch(userRepositoryProvider);
    final result = await repository.getUserProfile(userId);
    
    return result.fold(
      (failure) {
        // 网络错误时返回缓存数据
        if (failure is NetworkFailure && state.hasValue) {
          return state.valueOrNull;
        }
        throw failure;
      },
      (user) {
        _lastFetchTime = now;
        return user;
      },
    );
  }

  Future<void> invalidateCache() async {
    _lastFetchTime = null;
    ref.invalidateSelf();
  }
}

// ✅ 离线优先策略
@riverpod
class OfflineFirstUsers extends _$OfflineFirstUsers {
  @override
  Stream<List<User>> build() async* {
    final repository = ref.watch(userRepositoryProvider);
    
    try {
      // 1. 先返回本地缓存
      final cachedUsers = await repository.getCachedUsers();
      if (cachedUsers.isNotEmpty) {
        yield cachedUsers;
      }
      
      // 2. 尝试从网络获取最新数据
      final networkUsers = await repository.getRemoteUsers();
      yield networkUsers;
      
    } catch (error) {
      // 3. 网络失败时保持本地数据
      final cachedUsers = await repository.getCachedUsers();
      if (cachedUsers.isNotEmpty) {
        yield cachedUsers;
      } else {
        rethrow;
      }
    }
  }
}
```

### 3. 内存管理
```dart
// ✅ 自动清理不再使用的 Provider
@riverpod
class UserProfileCache extends _$UserProfileCache {
  Timer? _cleanupTimer;

  @override
  Map<String, User> build() {
    // 定期清理缓存
    _cleanupTimer = Timer.periodic(
      const Duration(minutes: 10),
      (_) => _cleanupOldEntries(),
    );
    
    ref.onDispose(() {
      _cleanupTimer?.cancel();
    });
    
    return {};
  }

  void _cleanupOldEntries() {
    final now = DateTime.now();
    final oldEntries = state.entries.where((entry) {
      // 假设 User 有 lastAccessTime 字段
      return now.difference(entry.value.lastAccessTime).inMinutes > 30;
    }).toList();
    
    for (final entry in oldEntries) {
      final newState = Map<String, User>.from(state);
      newState.remove(entry.key);
      state = newState;
    }
  }

  void cacheUser(User user) {
    state = {...state, user.id: user};
  }

  User? getUser(String userId) {
    return state[userId];
  }
}
```

## 国际化和主题

### 1. 国际化配置
```dart
// ✅ 本地化 Provider
@riverpod
Locale currentLocale(CurrentLocaleRef ref) {
  final prefs = ref.watch(sharedPreferencesProvider);
  final languageCode = prefs.valueOrNull?.getString('language_code') ?? 'en';
  return Locale(languageCode);
}

@riverpod
class LocaleNotifier extends _$LocaleNotifier {
  @override
  Locale build() {
    return ref.watch(currentLocaleProvider);
  }

  Future<void> changeLocale(Locale locale) async {
    final prefs = await ref.read(sharedPreferencesProvider.future);
    await prefs.setString('language_code', locale.languageCode);
    state = locale;
  }
}

// ✅ 在 MaterialApp 中使用
class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final router = ref.watch(goRouterProvider);
    final locale = ref.watch(localeNotifierProvider);
    final themeMode = ref.watch(themeModeNotifierProvider);

    return MaterialApp.router(
      title: 'My App',
      routerConfig: router,
      locale: locale,
      themeMode: themeMode,
      theme: AppTheme.lightTheme,
      darkTheme: AppTheme.darkTheme,
      localizationsDelegates: const [
        AppLocalizations.delegate,
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en'),
        Locale('zh'),
      ],
    );
  }
}
```

### 2. 动态主题
```dart
// ✅ 主题 Provider
@riverpod
ThemeMode currentThemeMode(CurrentThemeModeRef ref) {
  final prefs = ref.watch(sharedPreferencesProvider);
  final themeModeString = prefs.valueOrNull?.getString('theme_mode') ?? 'system';
  
  return switch (themeModeString) {
    'light' => ThemeMode.light,
    'dark' => ThemeMode.dark,
    _ => ThemeMode.system,
  };
}

@riverpod
class ThemeModeNotifier extends _$ThemeModeNotifier {
  @override
  ThemeMode build() {
    return ref.watch(currentThemeModeProvider);
  }

  Future<void> changeThemeMode(ThemeMode themeMode) async {
    final prefs = await ref.read(sharedPreferencesProvider.future);
    final themeModeString = switch (themeMode) {
      ThemeMode.light => 'light',
      ThemeMode.dark => 'dark',
      ThemeMode.system => 'system',
    };
    
    await prefs.setString('theme_mode', themeModeString);
    state = themeMode;
  }
}

// ✅ 自适应颜色方案
@riverpod
ColorScheme colorScheme(ColorSchemeRef ref, Brightness brightness) {
  // 可以基于用户偏好或品牌色生成
  const seedColor = Colors.blue;
  
  return ColorScheme.fromSeed(
    seedColor: seedColor,
    brightness: brightness,
  );
}
```

## 数据持久化和同步

### 1. 本地存储管理
```dart
// ✅ 本地存储服务
@riverpod
LocalStorageService localStorageService(LocalStorageServiceRef ref) {
  final prefs = ref.watch(sharedPreferencesProvider);
  return LocalStorageService(prefs.valueOrNull!);
}

class LocalStorageService {
  LocalStorageService(this._prefs);
  
  final SharedPreferences _prefs;

  // ✅ 类型安全的存储方法
  Future<bool> setString(String key, String value) {
    return _prefs.setString(key, value);
  }

  String? getString(String key) {
    return _prefs.getString(key);
  }

  Future<bool> setObject<T>(String key, T object) {
    final jsonString = jsonEncode(object);
    return _prefs.setString(key, jsonString);
  }

  T? getObject<T>(String key, T Function(Map<String, dynamic>) fromJson) {
    final jsonString = _prefs.getString(key);
    if (jsonString == null) return null;
    
    try {
      final jsonMap = jsonDecode(jsonString) as Map<String, dynamic>;
      return fromJson(jsonMap);
    } catch (e) {
      AppLogger.e('Error parsing stored object for key: $key', e);
      return null;
    }
  }

  Future<bool> remove(String key) {
    return _prefs.remove(key);
  }

  Future<bool> clear() {
    return _prefs.clear();
  }
}
```

### 2. 数据同步策略
```dart
// ✅ 数据同步服务
@riverpod
class SyncService extends _$SyncService {
  Timer? _syncTimer;

  @override
  SyncStatus build() {
    _startPeriodicSync();
    
    ref.onDispose(() {
      _syncTimer?.cancel();
    });
    
    return const SyncStatus.idle();
  }

  void _startPeriodicSync() {
    _syncTimer = Timer.periodic(
      const Duration(minutes: 5),
      (_) => syncData(),
    );
  }

  Future<void> syncData() async {
    if (state == const SyncStatus.syncing()) return;
    
    state = const SyncStatus.syncing();
    
    try {
      // 1. 上传本地待同步数据
      await _uploadPendingData();
      
      // 2. 下载远程更新
      await _downloadUpdates();
      
      // 3. 解决冲突
      await _resolveConflicts();
      
      state = SyncStatus.success(DateTime.now());
    } catch (error) {
      state = SyncStatus.error(error.toString());
    }
  }

  Future<void> _uploadPendingData() async {
    final pendingData = await ref.read(
      localStorageServiceProvider
    ).getObject('pending_sync_data', (json) => json);
    
    if (pendingData != null) {
      // 上传逻辑
      await ref.read(apiServiceProvider).post('/sync/upload', data: pendingData);
      await ref.read(localStorageServiceProvider).remove('pending_sync_data');
    }
  }
}

// ✅ 同步状态
@freezed
class SyncStatus with _$SyncStatus {
  const factory SyncStatus.idle() = _Idle;
  const factory SyncStatus.syncing() = _Syncing;
  const factory SyncStatus.success(DateTime lastSyncTime) = _Success;
  const factory SyncStatus.error(String message) = _Error;
}
```

## 代码质量检查清单

### 架构检查
- [ ] ✅ 是否正确使用 Riverpod Generator？
- [ ] ✅ Provider 是否按功能合理分组？
- [ ] ✅ 是否避免了 Provider 之间的循环依赖？
- [ ] ✅ 路由配置是否类型安全？
- [ ] ✅ 网络层是否有统一的错误处理？

### 性能检查
- [ ] ✅ 是否使用 select 优化 Widget 重建？
- [ ] ✅ 是否正确使用 ConsumerWidget 和 Consumer？
- [ ] ✅ 长列表是否使用 ListView.builder？
- [ ] ✅ 是否有合理的缓存策略？
- [ ] ✅ 是否及时释放资源和取消订阅？

### 用户体验检查
- [ ] ✅ 加载状态是否有适当提示？
- [ ] ✅ 错误状态是否友好展示？
- [ ] ✅ 离线状态是否正确处理？
- [ ] ✅ 路由切换是否流畅？
- [ ] ✅ 是否支持下拉刷新和上拉加载？

### 数据流检查
- [ ] ✅ 状态更新是否可预测？
- [ ] ✅ 副作用是否正确处理？
- [ ] ✅ 是否有数据竞态条件？
- [ ] ✅ 本地和远程数据是否同步？
- [ ] ✅ 是否有数据验证和清理？

### 测试检查
- [ ] ✅ Provider 是否可以被 Mock？
- [ ] ✅ Widget 是否易于测试？
- [ ] ✅ 网络请求是否可以离线测试？
- [ ] ✅ 路由导航是否可以测试？
- [ ] ✅ 错误场景是否有测试覆盖？

---

**推荐依赖配置**:

```yaml
dependencies:
  flutter:
    sdk: flutter
  
  # 状态管理
  flutter_riverpod: ^2.4.9
  riverpod_annotation: ^2.3.3
  
  # 路由
  go_router: ^12.1.3
  
  # 网络
  dio: ^5.4.0
  connectivity_plus: ^5.0.2
  
  # 数据处理
  freezed_annotation: ^2.4.1
  json_annotation: ^4.8.1
  dartz: ^0.10.1
  
  # 本地存储
  shared_preferences: ^2.2.2
  
  # 工具
  equatable: ^2.0.5
  logger: ^2.0.2
  
dev_dependencies:
  build_runner: ^2.4.7
  riverpod_generator: ^2.3.9
  freezed: ^2.4.6
  json_serializable: ^6.7.1
  flutter_test:
    sdk: flutter
  mocktail: ^1.0.2
```

**使用步骤**:
1. 将此规则保存为 `.cursorrules` 文件
2. 添加依赖并运行 `flutter pub get`
3. 运行 `flutter packages pub run build_runner build` 生成代码
4. 配置 `main.dart` 中的 ProviderScope 和路由
5. Cursor AI 将自动应用这些规则生成符合最佳实践的代码